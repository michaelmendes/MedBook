# MEDBOOK
An Electronic Health Records System.

# Project Summary
The healthcare systems in the provinces of Canada mainly rely on the use of physical medical record documents. This negatively impacts the ease of access of such documents for both physicians and patients, and delays the transfer of information from one clinician to another (e.g. from a family physician to a specialist clinician) since these documents must be transferred using outdated and error-prone techniques such as faxing. Therefore, this project aims at building an electronic health record system, hereby referred to as MedBook, to facilitate the storage and transfer of medical records to enable quick and efficient access by individuals involved in the healthcare system. Our application targets three different, yet interrelated, categories of users: clinicians, family physicians, and patients. Each user is able to view a different aspect of the system that is unique to their use case. The main development objective was to create a seamless system that allows a user to login with their unique credentials, and have access to a UI with views and actions specific to their user type. 

A patient user-type has the most limited view and set of actions in this system. The two main purposes of the patient view is: 1. A patient can view their medical record, 2. A patient can record and track their symptoms and health concerns using a diary feature. A patient is able to view their own personal medical record, which includes the following information: name, date of birth, sex, diagnosis history, vaccination history, allergies, surgical history, current prescriptions, and their diary entries. The diary entries section is a feature we decided to implement so that a patient’s family physician can refer to it and see precise information about their patient’s symptoms/ health condition that may otherwise have been forgotten if the patient didn’t have time to visit their family physician. The graphical interface for this had to be user-friendly to allow users with less experience with technology to still easily access the system. 

A family physician user-type accesses the largest range of actions. A family physician is defined as someone who has a set list of patients who they treat over a long term. The family physician user-type can therefore access the medical records of all the patients in their list. They can add a new patient to their list (such as when a family physician accepts a new patient), remove a patient from their list (such as when a patient will no longer treated by this family physician), and transfer a patient to another family physician (such as when a patient is moving to a new city and/or changing to a different family clinic). For each patient in their list, the family-physician user-type is able to view their entire medical record, and add or remove diagnoses, vaccinations, allergies, surgeries, and prescriptions. 

For any clinician that is not a family physician, they would access the clinician view. This is meant for individuals such as specialist physicians (e.g. cardiologist, dermatologist), or other individuals in healthcare (e.g. dentist, physical therapist). In our system, such a clinician would not have a set list of patients that they are treating. Rather, they would need to request to view the medical record of any specific patient who they are having an appointment with. The request would be sent to that patient’s family physician, who would then need to approve the request from their side. Once this request has been approved, a clinician can view the patient’s medical record, and add or remove diagnoses, vaccinations, allergies, surgeries, and prescriptions. 


# Key Accomplishments
There were many things that were successful in our implementation of MedBook. Firstly, despite lacking experience with databases, we were able to set up a strong database system for storing the clinicians and medical records, with separate tables for multi-valued attributes such as vaccinations and surgical history. We were also successfully able to link these tables to the appropriate patient and/or clinician using foreign keys, enabling the fast and effective retrieval of information when it needed to be displayed on the UI. We expected the “request” feature (for patient transfer to another family physician or viewing of a patient’s medical record by a clinician) to be the most difficult to implement, since it would involve accessing different databases and changing a lot of our dependencies. However, due to the set up of our databases, the feature was implemented seamlessly into our system, at least on the backend. 

We implemented a class called DBService, which implemented the Singleton design pattern. This was extremely useful, because our entire system was trying to access the database, so we wanted to ensure the servers weren’t conflicting with one another when trying to interact with the database. Furthermore, DBService had a method that allowed us to execute the different SQL statements for inserting, deleting, etc. without cluttering the classes that use it. This made our code a lot more readable, and also allowed us to implement the database actions quickly.

In addition, our UI for all three user types displays the exact required information for that user, with no additional or missing functionality. In terms of the clinician and family physician classes, since they had a lot of overlapping functions, such as viewing their list of patients and viewing a patient’s individual record, we made the family physician class a subclass of the clinician class. Using inheritance in this way allowed us to reduce redundant code and ensured that any changes made to the clinician classes applied to the family physician classes as well, which helped reduce the number of potential errors. 

We also had classes for all the user types: Clinician, FamilyPhysician, and Patient. Since these classes have many of the same properties, including name and type, we decided to implement one User superclass containing the shared methods of these classes (e.g. getter and setter methods for member variables), and then subclasses for clinician, family physician, and patient with properties and methods unique to each one. Objects of these classes were passed around between different components of our system, such as from the UI to the server, and from the server to other helper classes. The passing of objects rather than individual parameters ensured that the same information was being passed securely between classes. For example, the editRecord() function in the FamilyPhysicianServer class can be used for multiple different purposes from distinct methods in FamilyPhysicianUI (e.g. it may be used to add a diagnosis or remove a prescription). The passing of patient objects from the UI to the server ensures that all calls being made pass the same information with regards to a patient, and reduces any uncertainty for the front-end developers. 

Another thing that worked out was our idea to implement the strategy design pattern for the editRecord() function in our FamilyPhysicianServer class. We were able to send a string from the user interface to the server, and then the server executed the behavior that was needed based on that string to access and modify our sqlite database. This adhered to the single responsibility principle, resulting in high cohesion for this class, and increasing the reusability, robustness, and understandability of our code. This also follows the open/closed principle, since the main class that performs edits to the database is the RecordEditor, and the source code for this does not need to be changed. Rather, if we wanted to add a new functionality to this later (such as the ability to edit individual diagnoses, prescriptions etc., which is not something that was implemented here), we would just need to extend the class. Our use of the strategy design pattern allowed us to avoid errors, as the function for adding vs removing a record was interchangeable, and encapsulated working with the record so we would only have to make changes in one place if we wanted to add new functionality with regards to database access. 

The suggested cross-platform IDE, Qt Creator, was found to be really useful in creating the graphical user interface. Once we got the hang of it, it was a convenient tool to utilize for designing the interface. The interface made the project look user-friendly.  
 
# Key Problem Areas
Another challenge that we encountered was connecting the backend with the frontend. Due to the simple factory design that was implemented, we ran into a multitude of issues when trying to connect everything together. Since a small mistake in the input string could change the output, we had to be careful about our formats. In order to solve our issues, we worked to ensure that each method followed the same input format and had a similar output to better match what the frontend user interface was expecting.

In addition, since we were working with Sqlite and database tables, we encountered a multitude of issues due to differences in table and attribute naming, as well as working with select and other sql commands. This occurred because we initially had not discussed any naming conditions, so there was some confusion between group members. In one of our early meetings, we meticulously walked through all of the tables that exist, the columns they would have, and what they would be called, and this ensured that we were all on the same page with regards to the information stored in the database. Going forward, we solved this by renaming our existing tables so that they all followed a similar pattern and naming conventions.

Another problem came up when working with Qt creator. Although beneficial, it came with a lot of technical challenges. We especially faced problems when trying to sync our code with the IDE. In order to fix the issues, we spent a big chunk of time researching and implementing solutions. We were finally able to fix the issue between Windows and Mac by importing the source code of sqlite3.c and of sqlite3.h directly into our project.

Despite our efforts, however, issues still appeared with Qt creator. Due to this, those who worked on the UI had more of a difficult time integrating the backend code so that it ran properly. We solved this issue by having an online meeting to best understand what the other person’s ideas and plans are.

Another minor issue that we faced was maintaining the same naming style for classes, files, and objects. Merging is again the main issue here– largely due to some miscommunication and not fully hashing out the details at the beginning of the project, the naming style would often be switched back and forth. This caused it to be difficult for team members to run the code on their own PCs after merging. To fix this issue, after discussing with team members and notifying them of the change, each inconsistency was globally replaced and renamed.

 
# Lessons Learned

Something we would do the same is hold regular group meetings to talk about current progress. Having a regular meeting time helped us stay on track with our duties and notice problems earlier rather than later. It also helped by having individuals talk about the changes they had made to the main branch so that the rest of the team could understand the reason behind it.

An area we could improve is the method we return information to a patient or clinician. Currently we return the information through the user interface, but the user does not have a method of retrieving that information. An improvement would be to create a pdf file with the same information that the user could download from the app and print to use for whatever they want. This would allow our program to work more fluidly in a real-life situation by allowing our data to be shared through different means. We could implement log out feature as well for all three types or user.

Something that we would do differently if we were to do this project again, would be pushing our updates to our own branches, and then merging it all together at a later step. Since the entire team worked on the master branch, we encountered a lot of merge conflicts which took up a lot of time to fix. Working on our own branch while we finalized the code would stop us from pushing code that was only half done to the master branch as well. But for working in group projects like this, the Atlassian software was helpful and since they are industry standard platforms, we can be sure of this knowledge in the applied fields. 

We should have spent more time in merging the parts of the system written by each of us to make sure that the whole system as one single project was producing the desired outcome. We should have put more emphasis on working simultaneously as a group. This is something we would prioritize more if we were to do this project again. 
 
It would definitely be interesting to work on a similar project again in the future. A client database user interface is common in many different practices, and so further knowledge and experience will give us important skills we can use in the future. 

 
# Future Directions

If we were to continue with our program, there is a multitude of features that we would be interested in implementing. It would be a very exciting challenge for us as it would incorporate material that our team is not too familiar with (facial recognition AI, fitness tracker APIs). We can build new plug-ins for adding more features using AI. To predict changes in patient health conditions, transfer learning can be used here as the sample data for one patient will not be enough in cases like this to train a neural network architecture. Finding the pre-trained model for that will be crucial here as the prediction needs to be as accurate as possible and high validation accuracy is not the only metric to consider here. Reinforcement learning, although it still does not work perfectly in real-time cases, could be introduced to a project like this as well to strengthen the technological base. Incorporating some emerging machine learning and computer vision techniques would definitely give the product a competitive edge. 

To add an extra layer of security, we can add log-out feature for the users of all three categories and the log-in server should be able to match the ID in addition to the name. Another feature that we can add on top of what we already have is the removing patient feature that will enable the database administrator and the family physicians to remove patients respectively from the database and their lists.

Another feature that we would implement is the ability to preapprove patient information to certain clinicians and physicians. This would allow a faster flow of information between different users and allow the program to function more similarly to a real-life scenario.

Contributer: Michael Mendes (Project Lead)
